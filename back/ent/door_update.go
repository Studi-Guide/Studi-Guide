// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"studi-guide/ent/door"
	"studi-guide/ent/pathnode"
	"studi-guide/ent/predicate"
	"studi-guide/ent/sequence"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
)

// DoorUpdate is the builder for updating Door entities.
type DoorUpdate struct {
	config
	Id               *int
	addId            *int
	sequence         map[int]struct{}
	pathNodes        map[int]struct{}
	clearedSequence  bool
	clearedPathNodes bool
	predicates       []predicate.Door
}

// Where adds a new predicate for the builder.
func (du *DoorUpdate) Where(ps ...predicate.Door) *DoorUpdate {
	du.predicates = append(du.predicates, ps...)
	return du
}

// SetID sets the Id field.
func (du *DoorUpdate) SetID(i int) *DoorUpdate {
	du.Id = &i
	du.addId = nil
	return du
}

// AddID adds i to Id.
func (du *DoorUpdate) AddID(i int) *DoorUpdate {
	if du.addId == nil {
		du.addId = &i
	} else {
		*du.addId += i
	}
	return du
}

// SetSequenceID sets the sequence edge to Sequence by id.
func (du *DoorUpdate) SetSequenceID(id int) *DoorUpdate {
	if du.sequence == nil {
		du.sequence = make(map[int]struct{})
	}
	du.sequence[id] = struct{}{}
	return du
}

// SetNillableSequenceID sets the sequence edge to Sequence by id if the given value is not nil.
func (du *DoorUpdate) SetNillableSequenceID(id *int) *DoorUpdate {
	if id != nil {
		du = du.SetSequenceID(*id)
	}
	return du
}

// SetSequence sets the sequence edge to Sequence.
func (du *DoorUpdate) SetSequence(s *Sequence) *DoorUpdate {
	return du.SetSequenceID(s.ID)
}

// SetPathNodesID sets the pathNodes edge to PathNode by id.
func (du *DoorUpdate) SetPathNodesID(id int) *DoorUpdate {
	if du.pathNodes == nil {
		du.pathNodes = make(map[int]struct{})
	}
	du.pathNodes[id] = struct{}{}
	return du
}

// SetNillablePathNodesID sets the pathNodes edge to PathNode by id if the given value is not nil.
func (du *DoorUpdate) SetNillablePathNodesID(id *int) *DoorUpdate {
	if id != nil {
		du = du.SetPathNodesID(*id)
	}
	return du
}

// SetPathNodes sets the pathNodes edge to PathNode.
func (du *DoorUpdate) SetPathNodes(p *PathNode) *DoorUpdate {
	return du.SetPathNodesID(p.ID)
}

// ClearSequence clears the sequence edge to Sequence.
func (du *DoorUpdate) ClearSequence() *DoorUpdate {
	du.clearedSequence = true
	return du
}

// ClearPathNodes clears the pathNodes edge to PathNode.
func (du *DoorUpdate) ClearPathNodes() *DoorUpdate {
	du.clearedPathNodes = true
	return du
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (du *DoorUpdate) Save(ctx context.Context) (int, error) {
	if len(du.sequence) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"sequence\"")
	}
	if len(du.pathNodes) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"pathNodes\"")
	}
	return du.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (du *DoorUpdate) SaveX(ctx context.Context) int {
	affected, err := du.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (du *DoorUpdate) Exec(ctx context.Context) error {
	_, err := du.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (du *DoorUpdate) ExecX(ctx context.Context) {
	if err := du.Exec(ctx); err != nil {
		panic(err)
	}
}

func (du *DoorUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   door.Table,
			Columns: door.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: door.FieldID,
			},
		},
	}
	if ps := du.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := du.Id; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: door.FieldID,
		})
	}
	if value := du.addId; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: door.FieldID,
		})
	}
	if du.clearedSequence {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.SequenceTable,
			Columns: []string{door.SequenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: sequence.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := du.sequence; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.SequenceTable,
			Columns: []string{door.SequenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: sequence.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if du.clearedPathNodes {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.PathNodesTable,
			Columns: []string{door.PathNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: pathnode.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := du.pathNodes; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.PathNodesTable,
			Columns: []string{door.PathNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: pathnode.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, du.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// DoorUpdateOne is the builder for updating a single Door entity.
type DoorUpdateOne struct {
	config
	id               int
	Id               *int
	addId            *int
	sequence         map[int]struct{}
	pathNodes        map[int]struct{}
	clearedSequence  bool
	clearedPathNodes bool
}

// SetID sets the Id field.
func (duo *DoorUpdateOne) SetID(i int) *DoorUpdateOne {
	duo.Id = &i
	duo.addId = nil
	return duo
}

// AddID adds i to Id.
func (duo *DoorUpdateOne) AddID(i int) *DoorUpdateOne {
	if duo.addId == nil {
		duo.addId = &i
	} else {
		*duo.addId += i
	}
	return duo
}

// SetSequenceID sets the sequence edge to Sequence by id.
func (duo *DoorUpdateOne) SetSequenceID(id int) *DoorUpdateOne {
	if duo.sequence == nil {
		duo.sequence = make(map[int]struct{})
	}
	duo.sequence[id] = struct{}{}
	return duo
}

// SetNillableSequenceID sets the sequence edge to Sequence by id if the given value is not nil.
func (duo *DoorUpdateOne) SetNillableSequenceID(id *int) *DoorUpdateOne {
	if id != nil {
		duo = duo.SetSequenceID(*id)
	}
	return duo
}

// SetSequence sets the sequence edge to Sequence.
func (duo *DoorUpdateOne) SetSequence(s *Sequence) *DoorUpdateOne {
	return duo.SetSequenceID(s.ID)
}

// SetPathNodesID sets the pathNodes edge to PathNode by id.
func (duo *DoorUpdateOne) SetPathNodesID(id int) *DoorUpdateOne {
	if duo.pathNodes == nil {
		duo.pathNodes = make(map[int]struct{})
	}
	duo.pathNodes[id] = struct{}{}
	return duo
}

// SetNillablePathNodesID sets the pathNodes edge to PathNode by id if the given value is not nil.
func (duo *DoorUpdateOne) SetNillablePathNodesID(id *int) *DoorUpdateOne {
	if id != nil {
		duo = duo.SetPathNodesID(*id)
	}
	return duo
}

// SetPathNodes sets the pathNodes edge to PathNode.
func (duo *DoorUpdateOne) SetPathNodes(p *PathNode) *DoorUpdateOne {
	return duo.SetPathNodesID(p.ID)
}

// ClearSequence clears the sequence edge to Sequence.
func (duo *DoorUpdateOne) ClearSequence() *DoorUpdateOne {
	duo.clearedSequence = true
	return duo
}

// ClearPathNodes clears the pathNodes edge to PathNode.
func (duo *DoorUpdateOne) ClearPathNodes() *DoorUpdateOne {
	duo.clearedPathNodes = true
	return duo
}

// Save executes the query and returns the updated entity.
func (duo *DoorUpdateOne) Save(ctx context.Context) (*Door, error) {
	if len(duo.sequence) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"sequence\"")
	}
	if len(duo.pathNodes) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"pathNodes\"")
	}
	return duo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (duo *DoorUpdateOne) SaveX(ctx context.Context) *Door {
	d, err := duo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return d
}

// Exec executes the query on the entity.
func (duo *DoorUpdateOne) Exec(ctx context.Context) error {
	_, err := duo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (duo *DoorUpdateOne) ExecX(ctx context.Context) {
	if err := duo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (duo *DoorUpdateOne) sqlSave(ctx context.Context) (d *Door, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   door.Table,
			Columns: door.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  duo.id,
				Type:   field.TypeInt,
				Column: door.FieldID,
			},
		},
	}
	if value := duo.Id; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: door.FieldID,
		})
	}
	if value := duo.addId; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: door.FieldID,
		})
	}
	if duo.clearedSequence {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.SequenceTable,
			Columns: []string{door.SequenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: sequence.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := duo.sequence; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.SequenceTable,
			Columns: []string{door.SequenceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: sequence.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if duo.clearedPathNodes {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.PathNodesTable,
			Columns: []string{door.PathNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: pathnode.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := duo.pathNodes; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   door.PathNodesTable,
			Columns: []string{door.PathNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: pathnode.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	d = &Door{config: duo.config}
	_spec.Assign = d.assignValues
	_spec.ScanValues = d.scanValues()
	if err = sqlgraph.UpdateNode(ctx, duo.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return d, nil
}
