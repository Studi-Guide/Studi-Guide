// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"studi-guide/ent/door"
	"studi-guide/ent/room"
	"studi-guide/ent/sequence"

	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
)

// SequenceCreate is the builder for creating a Sequence entity.
type SequenceCreate struct {
	config
	X_Start *int
	Y_Start *int
	X_End   *int
	Y_End   *int
	Id      *int
	door    map[int]struct{}
	room    map[int]struct{}
}

// SetXStart sets the X_Start field.
func (sc *SequenceCreate) SetXStart(i int) *SequenceCreate {
	sc.X_Start = &i
	return sc
}

// SetNillableXStart sets the X_Start field if the given value is not nil.
func (sc *SequenceCreate) SetNillableXStart(i *int) *SequenceCreate {
	if i != nil {
		sc.SetXStart(*i)
	}
	return sc
}

// SetYStart sets the Y_Start field.
func (sc *SequenceCreate) SetYStart(i int) *SequenceCreate {
	sc.Y_Start = &i
	return sc
}

// SetNillableYStart sets the Y_Start field if the given value is not nil.
func (sc *SequenceCreate) SetNillableYStart(i *int) *SequenceCreate {
	if i != nil {
		sc.SetYStart(*i)
	}
	return sc
}

// SetXEnd sets the X_End field.
func (sc *SequenceCreate) SetXEnd(i int) *SequenceCreate {
	sc.X_End = &i
	return sc
}

// SetNillableXEnd sets the X_End field if the given value is not nil.
func (sc *SequenceCreate) SetNillableXEnd(i *int) *SequenceCreate {
	if i != nil {
		sc.SetXEnd(*i)
	}
	return sc
}

// SetYEnd sets the Y_End field.
func (sc *SequenceCreate) SetYEnd(i int) *SequenceCreate {
	sc.Y_End = &i
	return sc
}

// SetNillableYEnd sets the Y_End field if the given value is not nil.
func (sc *SequenceCreate) SetNillableYEnd(i *int) *SequenceCreate {
	if i != nil {
		sc.SetYEnd(*i)
	}
	return sc
}

// SetID sets the Id field.
func (sc *SequenceCreate) SetID(i int) *SequenceCreate {
	sc.Id = &i
	return sc
}

// SetDoorID sets the door edge to Door by id.
func (sc *SequenceCreate) SetDoorID(id int) *SequenceCreate {
	if sc.door == nil {
		sc.door = make(map[int]struct{})
	}
	sc.door[id] = struct{}{}
	return sc
}

// SetNillableDoorID sets the door edge to Door by id if the given value is not nil.
func (sc *SequenceCreate) SetNillableDoorID(id *int) *SequenceCreate {
	if id != nil {
		sc = sc.SetDoorID(*id)
	}
	return sc
}

// SetDoor sets the door edge to Door.
func (sc *SequenceCreate) SetDoor(d *Door) *SequenceCreate {
	return sc.SetDoorID(d.ID)
}

// SetRoomID sets the room edge to Room by id.
func (sc *SequenceCreate) SetRoomID(id int) *SequenceCreate {
	if sc.room == nil {
		sc.room = make(map[int]struct{})
	}
	sc.room[id] = struct{}{}
	return sc
}

// SetNillableRoomID sets the room edge to Room by id if the given value is not nil.
func (sc *SequenceCreate) SetNillableRoomID(id *int) *SequenceCreate {
	if id != nil {
		sc = sc.SetRoomID(*id)
	}
	return sc
}

// SetRoom sets the room edge to Room.
func (sc *SequenceCreate) SetRoom(r *Room) *SequenceCreate {
	return sc.SetRoomID(r.ID)
}

// Save creates the Sequence in the database.
func (sc *SequenceCreate) Save(ctx context.Context) (*Sequence, error) {
	if sc.X_Start == nil {
		v := sequence.DefaultXStart
		sc.X_Start = &v
	}
	if sc.Y_Start == nil {
		v := sequence.DefaultYStart
		sc.Y_Start = &v
	}
	if sc.X_End == nil {
		v := sequence.DefaultXEnd
		sc.X_End = &v
	}
	if sc.Y_End == nil {
		v := sequence.DefaultYEnd
		sc.Y_End = &v
	}
	if sc.Id == nil {
		return nil, errors.New("ent: missing required field \"Id\"")
	}
	if len(sc.door) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"door\"")
	}
	if len(sc.room) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"room\"")
	}
	return sc.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (sc *SequenceCreate) SaveX(ctx context.Context) *Sequence {
	v, err := sc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (sc *SequenceCreate) sqlSave(ctx context.Context) (*Sequence, error) {
	var (
		s     = &Sequence{config: sc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: sequence.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: sequence.FieldID,
			},
		}
	)
	if value := sc.X_Start; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: sequence.FieldXStart,
		})
		s.XStart = *value
	}
	if value := sc.Y_Start; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: sequence.FieldYStart,
		})
		s.YStart = *value
	}
	if value := sc.X_End; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: sequence.FieldXEnd,
		})
		s.XEnd = *value
	}
	if value := sc.Y_End; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: sequence.FieldYEnd,
		})
		s.YEnd = *value
	}
	if value := sc.Id; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: sequence.FieldID,
		})
		s.ID = *value
	}
	if nodes := sc.door; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   sequence.DoorTable,
			Columns: []string{sequence.DoorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: door.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := sc.room; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sequence.RoomTable,
			Columns: []string{sequence.RoomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: room.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if err := sqlgraph.CreateNode(ctx, sc.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	s.ID = int(id)
	return s, nil
}
